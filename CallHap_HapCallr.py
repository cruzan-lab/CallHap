#!/bin/python
# CallHap_HapCallr V. 1.01.00
#
# A program for determining full-genome haplotype frequencies in pooled DNA samples based on SNP calls and limited known haplotypes.  
# Takes as input a pair of VCF files describing haplotype identity and SNP frequency, as generated by CallHap VCF_Filt
# 
# Import necessary modules
import numpy as np
from argparse import ArgumentParser
import time
import sys
from Modules.VCF_parser import *
from Modules.CorrHaps import *
from Modules.CallHap_LeastSquares import *
from Modules.General import *
from Modules.IO import *
from Modules.parallel import *

progVersion = "V1.01.00"

def  MakeHaps(inSnpSets, inPoolSize, inOldHaps, inInitialFreqs, InitialHaps):
    # Module to create new haplotypes using input SNP sets and haplotype set.
    print("Making haplotypes with snp set %s" % inSnpSets)
    # Figure out what the less common identity for this SNP is in the current haplotype set
    snpIDs = [inOldHaps[x][inSnpSets[0]] for x in xrange(len(inOldHaps))]
    numSnps = len(inOldHaps[0])
    commonCounter = [snpIDs.count(0), snpIDs.count(1)]
    if commonCounter[0] > commonCounter[1]:
        rareAllele=1
    else:
        rareAllele=0
    #Figure out which haplotypes contain the less common variant    
    containingHaps = [True if inOldHaps[x][inSnpSets[0]] == rareAllele else False for x in xrange(len(inOldHaps))]
    if True in containingHaps: # If this SNP is in a known haplotype
        # Determine which SNPs can be legally changed in each haplotype
        legalSnpsByHap = ValidSnpsFromPhylogeny(inOldHaps)
        # Check which haplotypes the target SNP can be legally changed in
        # These are the ones that could be used to create new source haplotypes
        usableHaps = [True if inSnpSets[0] in legalSnpsByHap[hap] else False for hap in xrange(len(inOldHaps))]
    else: # If this SNP is not in a known haplotype
        # All haplotypes can be used to create new source haplotypes.
        usableHaps = [True for x in containingHaps]
    # Initialize lists of possible haplotype sets
    possibleFreqs = [inInitialFreqs[:]]
    possibleHaps = [inOldHaps]
    initialHaps = len(inOldHaps)
    
    freqSet = 0
    testStop = len(possibleFreqs)
    loopCtr1 = 0
    
    
    while freqSet < testStop:
        loopCtr1 += 1
        baseFreq = []
        for freq in xrange(len(possibleFreqs[freqSet])):
            
            if possibleFreqs[freqSet][freq] > 0 and usableHaps[freq] == True:
                baseFreq.append(freq)
        
        newFreq = 0
        loopCtr2 = 0
        while newFreq < len(baseFreq):
            loopCtr2 += 1
            if loopCtr2 > 1000:
                raise Exception("Too many iterations at line 342 with baseFreq = %s" % len(baseFreq))
            if baseFreq[newFreq] > initialHaps:
                if newFreq == len(baseFreq) - 1:
                    # Change the origional frequency set and haplotypes set
                    possibleFreqs[freqSet].append(1)
                    possibleHaps[freqSet].append(np.copy(possibleHaps[freqSet][baseFreq[newFreq]]))
                    for iter1 in inSnpSets:
                        possibleHaps[freqSet][-1][iter1] = 1 - possibleHaps[freqSet][-1][iter1]
                else:
                    # make a copy of the origional frequency set and haplotypes set
                    possibleFreqs.append([x for x in possibleFreqs[freqSet]])
                    possibleHaps.append([np.copy(x) for x in possibleHaps[freqSet]])
                    # change the copy
                    possibleFreqs[-1].append(1)
                    possibleHaps[-1].append(np.copy(possibleHaps[freqSet][newFreq]))
                    for iter1 in inSnpSets:
                        possibleHaps[-1][-1][iter1] = 1 - possibleHaps[-1][-1][iter1]
            else:

                if newFreq == len(baseFreq) - 1:
                    # Change the origional frequency set and haplotypes set
                    possibleFreqs[freqSet].append(1)
                    possibleHaps[freqSet].append(np.copy(possibleHaps[freqSet][baseFreq[newFreq]]))
                    for iter1 in inSnpSets:
                        possibleHaps[freqSet][-1][iter1] = 1 - possibleHaps[freqSet][-1][iter1]

                    if possibleFreqs[freqSet][baseFreq[newFreq]] == 0:
                        possibleFreqs[freqSet].pop(baseFreq[newFreq])
                        possibleHaps[freqSet].pop(baseFreq[newFreq])
                else:
                    # make a copy of the origional frequency set and haplotypes set
                    possibleFreqs.append([x for x in possibleFreqs[freqSet]])
                    possibleHaps.append([np.copy(x) for x in possibleHaps[freqSet]])
                    # change the copy
                    possibleFreqs[-1].append(1)
                    possibleHaps[-1].append(np.copy(possibleHaps[freqSet][baseFreq[newFreq]]))
                    for iter1 in inSnpSets:
                        possibleHaps[-1][-1][iter1] = 1 - possibleHaps[-1][-1][iter1]
                    if possibleFreqs[freqSet][baseFreq[newFreq]] == 0 and baseFreq[newFreq] >= InitialHaps:
                        possibleFreqs[freqSet].pop(baseFreq[newFreq])
                        possibleHaps[freqSet].pop(baseFreq[newFreq])
            newFreq += 1
        freqSet += 1
    return(possibleHaps)


    

if __name__ == "__main__":
    parser = ArgumentParser()
    parser.add_argument('-i','--inputHaps',action="store", dest="knownHaps", help = "A VCF-formated file containing the known haplotypes encoded in the GT field.  GT must be present in the FORMAT field, and ploidy must be 1.  ", required=True)
    parser.add_argument('-p', '--poolsize', action="store", type=int, dest="poolSize", help="The number of individuals in each pool.  ", required=True)
    parser.add_argument('-f','--inputFreqs', action="store", dest="inFreqs", help="A VCF-formated file containing the input pool frequencies.  ", required=True)
    parser.add_argument('-o','--outPrefix', action="store", dest="outPrefix", required=True, help="A prefix for output file names.  ")
    parser.add_argument("-v", "--version", action="store_true", dest="v", help="Displays the version number and exits.")
    parser.add_argument('-t', '--processes', type=int, action="store", dest="numProcesses", default=None, help="The number of processes to use.  Should not be more than the number of cores on your CPU.  Defaults to using the number of cores on your CPU.  ")
    parser.add_argument('-l','--numIterations', type=int, action="store", dest="numIterations", default=1, help="Number of iterations")
    parser.add_argument('-r','--highResidual', type=float, action="store", dest="highResidual", default=100, help="Cutoff value for delaying processing of a SNP until after all other SNPs have been processed")
    parser.add_argument('--dropFinal', action="store_true", dest="dropFinal", help="If after delaying processing on a SNP, the solution isn't improved by keeping it, drop the SNP.  If absent, the SNP will be processed as normal at the end.  ")
    o = parser.parse_args()
    
    if o.v:
        print(progVersion)
        exit()
    
    print("Running CallHap on %s at %s:" % (time.strftime("%d/%m/%Y"),time.strftime("%H:%M:%S")))
    print("Command = python CallHap_HapCallr.py --inputHaps %s --inputFreqs %s --poolSize %s --outPrefix %s" % (o.knownHaps, o.inFreqs, o.poolSize, o.outPrefix))
    outPrefix = "%s_Iteration1" % (o.outPrefix)
    # Load haplotypes
    KnownHaps, KnownNames = toNP_array(o.knownHaps, "GT")
    KnownHaps = invertArray(KnownHaps)
    inHapArray, UniqueNames = UniqueHaps(KnownHaps, KnownNames)
    numHapsInitial = len(UniqueNames)
    numSNPs = inHapArray.shape[0]
    inHapArray = ExtendHaps(inHapArray)
    bestArray = np.copy(inHapArray)
    
    NexusWriter(KnownNames, KnownHaps, numSNPs, o.outPrefix, "INITIAL", o.knownHaps)
    NexusWriter(UniqueNames, inHapArray, numSNPs, o.outPrefix, "Unique1", o.knownHaps)    
    
    # Load SNPs
    SnpFreqs, poolNames = toNP_array(o.inFreqs, "RF")
    SnpFreqs = ExtendHaps(SnpFreqs)
    numPools = len(poolNames)
    
    numHapsInitial = len(UniqueNames)    
    
    # Convert haplotypes and snps arrays to decimal format to prevent rounding errors
    bestArray = npToDecNp(bestArray)
    SnpFreqs = npToDecNp(SnpFreqs)
    
    # Find SNP sets
    
    print("Calculating base model fit...")
    # Find base SLSq
    baseSLSq = []
    baseFreqs = []
    baseResiduals = []
    for poolIter in xrange(numPools):
        tmpSol = Find_Freqs(bestArray, SnpFreqs[:,poolIter], o.poolSize)
        baseSLSq.append(tmpSol[1])
        baseFreqs.append(tmpSol[0])
        baseResiduals.append(np.array([[x] for x in list(residuals(tmpSol[0][0],bestArray, SnpFreqs[:,poolIter],o.poolSize))]))
    baseSnpResids = [sum([baseResiduals[pool][xSnp] for pool in xrange(numPools)]) for xSnp in xrange(numSNPs)]
    # Find overall SNP frequency
    snpFreqsTotal = np.sum(SnpFreqs, axis=1)
    snpCombins3 = [[x] for x in sorted(range(numSNPs), key = lambda x: snpFreqsTotal[x], reverse=True)]
    print("snpCombins3")    
    print(snpCombins3)
    #Find base AIC values
    baseAIC = AIC_from_RSS(sum(baseSLSq)/len(baseSLSq),numHapsInitial, numSNPs)
    baseAIC_test = [AIC_from_RSS(baseSLSq[x],numHapsInitial, numSNPs) for x in xrange(len(baseSLSq))]
    baseRSS = sum(baseSLSq)/len(baseSLSq)
    
    fullFreqs = [[0 for x in xrange(numHapsInitial)]]
    for testIter in xrange(numHapsInitial):
        for testIter2 in xrange(numPools):
            if baseFreqs[testIter2][0,testIter] > 0:
                fullFreqs[0][testIter] = 1
    potHapSets = [[np.copy(bestArray[:,x]) for x in xrange(numHapsInitial)]]
    numHaps = [numHapsInitial]
    bestAIC = [baseRSS]
    usedSnps = 0
    # Start adding SNPs
    for iteration in xrange(o.numIterations):
        print("Running iteration %s" % (iteration + 1))
        for combin in snpCombins3:
            usedSnps += 1
            print("Adding snp combination %s/%s" % (usedSnps, len(snpCombins3)))
            print("%s potential haplotype sets" % len(potHapSets))
            print("Best RSS values:")
            print(bestAIC)
            # test if this snp combination has any non-zero residuals
            useCombin = False
            for population in xrange(numPools):
                if abs(round(20*baseResiduals[population][combin[0]])) > 0:
                    useCombin = True
            # If this snp combination has non-zero residuals:
            if useCombin:
                print("Using SNP")
                newPotHapSets = []
                potHapSetsAIC = []
    #            newPotHapSetsMaxRSS = []
                sourceHapSet = []
                newFullFreqs = []
                # Find options for adding this SNP set:
                currentHapSet = 0
                snpRes = []
                for hapSet in potHapSets:
                    print("Finding options")
                    print("Making haplotypes")
                    if iteration > 0:
                        print(fullFreqs)
                    newPotHaps = MakeHaps(combin, o.poolSize, copy(hapSet), fullFreqs[0], numHapsInitial)
                    SLSqs = []
                    Freqs = []
                    testAICList = []
                    maxRSSList = []
                    srcHap = []
                    # Find the average SLSq for each pot hap set
                    newPotHaps2 = []
                    print("finding RSS")
                    tmpSols = easy_parallizeLS(newPotHaps, o.numProcesses, SnpFreqs, o.poolSize)
                    print("Solution RSS Values: ")
                    print([tmpSols[x][2] for x in xrange(len(tmpSols))])
                    
                    testAICList = [x for x in xrange(len(tmpSols)) if tmpSols[x][2] <= bestAIC[currentHapSet]]
                    srcHap = [currentHapSet for x in xrange(len(testAICList))]
                    newResiduals = []
                    changedResids = []
                    SnpResiduals = []
                    solIter = 0
                    for sol in tmpSols:
                        newFullFreqs.append([0 for x in xrange(len(sol[1][0][0]))])
                        for testIter in xrange(len(newFullFreqs[-1])):
                            for testIter2 in xrange(numPools):
                                if sol[1][testIter2][0,testIter] > 0:
                                    newFullFreqs[-1][testIter] = 1
                                newResiduals.append(np.array([[x] for x in list(residuals(sol[1][testIter2][0],np.concatenate([np.transpose(y[np.newaxis]) for y in newPotHaps[solIter]], axis=1), SnpFreqs[:,testIter2],o.poolSize))]))
                        SnpResiduals.append([sum([newResiduals[poolIter][x]**2 for poolIter in xrange(numPools)])/numPools for x in xrange(numSNPs)])
                        solIter += 1
                    if len(testAICList) > 0:
                        print("Filtering solutions")
                        # Filter to only the best solutions out of all proposed solutions
                        testIndex = sorted(range(len(testAICList)), key=lambda x: tmpSols[x][2])
                        if len(potHapSetsAIC) == 0:
                            testFreq = tmpSols[testIndex[0]][2]
                        elif tmpSols[testIndex[0]][2] >= min(potHapSetsAIC):
                            testFreq = min(potHapSetsAIC)
                        else:
                            testFreq = tmpSols[testIndex[0]][2]
                        if testFreq < bestAIC[currentHapSet]:
                            iter1 = 0
                            minAICIndex = []
                            continueLoop = True
                            while  iter1 < len(testIndex) and continueLoop:
                                newPotHapSets.append(copy(newPotHaps[testIndex[iter1]]))
                                potHapSetsAIC.append(tmpSols[testIndex[iter1]][2])
                                sourceHapSet.append(currentHapSet)
                                snpRes.append(snpRes1[testIndex[iter1]])
                                iter1 += 1
                        else:
                            minAICIndex = []
                    currentHapSet += 1
                continueCheck = [False if snpRes[x] >= o.highResidual else True for x in xrange(len(snpRes))]
                bestAICIdx = sorted(range(len(newPotHapSets)), key=lambda x: potHapSetsAIC[x])
                if len(bestAICIdx) > 0 and True in continueCheck:
                    bestFreq = potHapSetsAIC[bestAICIdx[0]]
                    potHapSets = []
                    bestAIC = []
                    iter1 = 0
                    minCtr = 0
                    newSourceHap = []
                    potHapSetsMaxRSS = []
                    while  iter1 < len(bestAICIdx):
                        if potHapSetsAIC[bestAICIdx[iter1]] == bestFreq and snpRes[bestAICIdx[iter1]] < o.highResidual:
                            minCtr += 1
                            potHapSets.append(copy(newPotHapSets[bestAICIdx[iter1]]))
                            bestAIC.append(potHapSetsAIC[bestAICIdx[iter1]])
                            newSourceHap.append(sourceHapSet[bestAICIdx[iter1]])
                        iter1 += 1
                    fullFreqs = newFullFreqs[:]
                    sourceHapSet = newSourceHap[:]
                    bestRSS = bestFreq
                    numHaps = [len(x) for x in potHapSets]
        SLSqs = []
        Freqs = []
        finFullFreqs = []
        SolutionHapSets = []
        SolutionAICs = []
        # Remove unused haplotypes from each potential final hap set
        tmpSols = easy_parallizeLS(potHapSets, o.numProcesses, SnpFreqs, o.poolSize)
        for hapSet in potHapSets:
            # Recalculate RSS, Freqs for each pool
            SLSqs.append([])
            Freqs.append([])
            for poolIter in xrange(numPools):
                tmpSol = Find_Freqs(np.concatenate([hapSet[x][np.newaxis].transpose() for x in xrange(len(hapSet))], axis=1), SnpFreqs[:,poolIter], o.poolSize)
                SLSqs[-1].append(tmpSol[1])
                Freqs[-1].append(tmpSol[0][0])
            finFullFreqs.append([0 for x in xrange(len(hapSet))])
            for testIter in xrange(len(hapSet)):
                for testIter2 in xrange(numPools):
                    if Freqs[0][testIter2][testIter] > 0:
                        finFullFreqs[-1][testIter] = 1
            SolutionHapSets.append([np.copy(hapSet[x]) for x in xrange(len(finFullFreqs[-1])) if finFullFreqs[-1][x] > 0 ])
            SolutionAICs.append(AIC_from_RSS(sum(SLSqs[-1])/len(SLSqs[-1]), sum(finFullFreqs[-1]), numSNPs))
            
        if o.dropFinal == True and iteration == o.numIterations - 1:
            newResiduals = []
            snpsToRemove = []
            solIter = 0
            for sol in tmpSols:
                for testIter in xrange(len(newFullFreqs)):
                    for testIter2 in xrange(numPools):
                        newResiduals.append(np.array([[x] for x in list(residuals(sol[1][testIter2][0],np.concatenate([np.transpose(y[np.newaxis]) for y in potHapSets[solIter]], axis=1), SnpFreqs[:,testIter2],o.poolSize))]))
                SnpResiduals = [sum([newResiduals[poolIter][x]**2 for poolIter in xrange(numPools)]) for x in xrange(numSNPs)]
                snpsToRemove.append([])
                for snpRemovalIter in xrange(numSNPs):
                    if SnpResiduals[snpRemovalIter] >= o.highResidual:
                        print("Removing SNP %s in solution %s" % (snpRemovalIter, solIter))
                        snpsToRemove[-1].append(snpRemovalIter)
                solIter += 1
        else:
            snpsToRemove = [[] for x in xrange(len(tmpSols))]
            
        
    
        
        # Figure out which has (have) the lowest AIC
        AIC_test_idx = sorted(range(len(SolutionAICs)), key = lambda x: SolutionAICs[x])
        finIndex = 0
        testFreq = SolutionAICs[AIC_test_idx[0]]
        iter1 = 0
        minAICIndex = []
        continueLoop = True
        while  iter1 < len(AIC_test_idx) and continueLoop:
            if SolutionAICs[AIC_test_idx[iter1]] == testFreq:
                finIndex += 1
            else:
                continueLoop = False
            iter1 += 1
        
        # Output solutions
        print("%s final solutions" % finIndex)
        newPotHapSets = []
        for outputIdx in xrange(finIndex):
            finSolution = np.concatenate([SolutionHapSets[AIC_test_idx[outputIdx]][x][np.newaxis].transpose() for x in xrange(len(SolutionHapSets[AIC_test_idx[outputIdx]]))], axis=1)
            finSolution = np.delete(finSolution, snpsToRemove[outputIdx], 0)
            myHapNames = []
            newHapNumber = 1
            for haplotypeIter in xrange(finSolution.shape[1]):
                if haplotypeIter >= len(UniqueNames):
                    myHapNames.append("NewHap_%s" % str(newHapNumber).zfill(2))
                    newHapNumber += 1
                else:
                    myHapNames.append(UniqueNames[haplotypeIter])
            finSolution, finNames = UniqueHaps(finSolution, myHapNames)
            finSNPs = np.delete(SnpFreqs,snpsToRemove[outputIdx],0)
            # Find solutions
            outFile = open("%s_%s.str" % (outPrefix, outputIdx), 'wb')
            outFile2 = open("%s_%s_freqs.csv" % (outPrefix, outputIdx), 'wb')
            outFile2.write("Population,")

            myDecHaps = []
            
            # Start writing the frequencies file
            for haplotypeIter in xrange(finSolution.shape[1]):
                myDecHaps.append(int("1"+"".join([str(int(x)) for x in finSolution[:, haplotypeIter]]),2))
            outFile2.write(",".join(finNames))
            outFile2.write(",RSS")
            outFile2.write("\n,%s" % ",".join([str(x) for x in myDecHaps]))
            
            SLSqs = []
            Freqs = []
            predSnpFreqs = []
            output3 = vcfWriter("%s_PredFreqs.vcf" % outPrefix, source="CallHaps_HapCallr_%s" % progVersion)
            output3.writeHeader(poolNames)
            output3.setFormat("RF")
            
            tmpVCF = vcfReader(o.knownHaps)
            #Chroms, Poss, Refs, Alts, Quals
            output3.importLinesInfo(tmpVCF.getData("chrom", lineTarget="a"),tmpVCF.getData("pos", lineTarget="a"), tmpVCF.getData("ref", lineTarget="a"),tmpVCF.getData("alt", lineTarget="a"), tmpVCF.getData("qual", lineTarget="a"))
            newResiduals = []
            output3.removeRows(snpsToRemove[outputIdx])
            for poolIter in xrange(numPools):
                tmpSol = Find_Freqs(finSolution, finSNPs[:,poolIter], o.poolSize)
                SLSqs.append(tmpSol[1])
                Freqs.append(tmpSol[0])
                
                outFile2.write("\n%s,%s" % (poolNames[poolIter],",".join([str(x) for x in tmpSol[0][0]])))
                outFile2.write(",%s" % tmpSol[1])
                outputProt(UniqueNames, tmpSol[0], finSolution, o.poolSize, poolNames, poolIter, outFile)
                newResiduals.append(np.array([[x] for x in list(residuals(tmpSol[0][0],finSolution, finSNPs[:,poolIter],o.poolSize))]))
                predSnpFreqs = np.sum(finSolution * tmpSol[0][0], axis = 1)
                output3.importSampleValues(list(predSnpFreqs), poolNames[poolIter])
            SnpResiduals = [sum([newResiduals[poolIter][x]**2 for poolIter in xrange(numPools)]) for x in xrange(numSNPs-len(snpsToRemove[outputIdx]))]
            output3.importInfo("RSS",SnpResiduals)
            output3.writeSamples()
            output3.close()
            outFile2.close()
            outFile.close()
            NexusWriter(finNames, finSolution, numSNPs - len(snpsToRemove[outputIdx]), outPrefix, outputIdx, o.knownHaps, snpsToRemove[outputIdx])
            newPotHapSets.append([np.copy(finSolution[:,x]) for x in xrange(finSolution.shape[1])])
        # Setup for next iteration
        usedSnps = 0
        numHapsInitial = len(myHapNames) # may need some fixing
        UniqueNames = myHapNames[:] # may need some fixing
        numHaps = [numHapsInitial for x in xrange(len(newPotHapSets))]
        outPrefix = "%s_Iteration%s" % (o.outPrefix, iteration + 2)
        potHapSets = newPotHapSets[:]
        bestAIC = [sum(SLSqs) for x in xrange(len(potHapSets))]
        fullFreqs = [[1 for x in xrange(len(potHapSets[y]))] for y in xrange(len(potHapSets))]